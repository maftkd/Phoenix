using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class Fly : MonoBehaviour
{
	public static Fly _instance;
	Hop _hop;
	public AudioClip _flip;
	public AudioClip _flap;
	AudioSource [] _flapSources;
	Collider[] _hitCheck;
	Vector3 _velocity;
	[Range(0,1f)]
	public float _upLerp;
	float _turnVal;
	public Vector2 _mouseSens;
	public float _maxPitch;
	public float _pitchMult;
	float _speed;
	float _turnRadius;
	public float _gravity;
	public float _accelPerFlap;
	public float _decel;
	public float _maxSpeed;
	public Vector3 _maxEulers;

	[Header("Debug")]
	public Text _speedText;
	public Text _velText;

	void Awake(){
		_instance=this;
		_flapSources = transform.Find("Flaps").GetComponentsInChildren<AudioSource>();
		_hitCheck = new Collider[5];
	}

	void OnDisable(){
		Cursor.lockState = CursorLockMode.None; 
		Cursor.visible=false;
	}

	void OnEnable(){
		Cursor.lockState = CursorLockMode.Locked; 
		Cursor.visible=false;
		if(_hop==null)
			_hop=Hop._instance;

		_velocity=Vector3.zero;
		_speed=0;

		Flip();
	}

    // Start is called before the first frame update
    void Start()
    {
    }

    // Update is called once per frame
    void Update()
    {
		//cursor
		if(Input.GetKeyDown(KeyCode.LeftControl)){
			Cursor.visible = !Cursor.visible;
			Cursor.lockState = Cursor.lockState==CursorLockMode.Locked? 
				CursorLockMode.None : CursorLockMode.Locked;
		}
		
		//pitch
		float mouseY = Input.GetAxis("Mouse Y");
		Vector3 eulers = transform.eulerAngles;
		eulers.x+=mouseY*_mouseSens.y*-1;
		if(eulers.x>180)
			eulers.x=-(360-eulers.x);
		else if(eulers.x<-180)
			eulers.x=(360+eulers.x);
		eulers.x = Mathf.Clamp(eulers.x,-_maxEulers.x,_maxEulers.x);
		//set eulers
		transform.eulerAngles=eulers;

		//turn
		float mouseX = Input.GetAxis("Mouse X");
		_turnVal+=mouseX*_mouseSens.x;
		float turnMax=_speed/_maxSpeed;
		_turnVal=Mathf.Clamp(_turnVal,-turnMax,turnMax);
		Vector3 eulerAngles = transform.eulerAngles;
		eulerAngles.z=-_turnVal*_maxPitch*_pitchMult;
		transform.eulerAngles=eulerAngles;


		//calc turn radius
		_turnRadius = (_speed*_speed)/(11.26f*Mathf.Tan(_turnVal*_maxPitch*Mathf.Deg2Rad));
		if(!float.IsNaN(_turnRadius)&&!float.IsInfinity(_turnRadius)){
			float travelDist=_speed*Time.deltaTime;
			float circumf=2*Mathf.Abs(_turnRadius)*Mathf.PI;
			float frac = travelDist/circumf;
			//Debug.Log("f: "+frac+", tr: "+_turnRadius+", circ: "+circumf);
			float ang = frac*360f*Mathf.Sign(_turnRadius);
			transform.RotateAround(transform.position+transform.right*_turnRadius,Vector3.up,ang);
			_velocity=Quaternion.Euler(Vector3.up*ang)*_velocity;
		}

		//wing flap
		if(Input.GetMouseButtonDown(0) || Input.GetMouseButtonDown(1)){
			Flip();
		}
		else if(Input.GetMouseButtonUp(0) || Input.GetMouseButtonUp(1)){
			Flap();
		}

		//gravity
		_velocity+=Vector3.down*_gravity*Time.deltaTime;
		_velocity.Normalize();

		_speed-=_decel*Time.deltaTime;
		if(_speed<1)
			_speed=1;

		transform.position+=_velocity*_speed*Time.deltaTime;


		//ground check
		if(Physics.OverlapSphereNonAlloc(transform.position,_hop._height,_hitCheck)>0){
			Debug.Log("ground check");
			enabled=false;
			_hop.enabled=true;
		}
        
		_speedText.text=_speed.ToString("0.00");
    }

	void Flip(){
		foreach(AudioSource a in _flapSources){
			//play audio
			if(!a.isPlaying){
				a.clip=_flip;
				a.Play();
				break;
			}
		}

		Vector3 vDiff = Vector3.Lerp(transform.forward,Vector3.up,_upLerp);
		vDiff.Normalize();
		//vDiff*=_accelPerFlap;
		_velocity+=vDiff;
		_speed+=_accelPerFlap;
		if(_speed>_maxSpeed){
			_speed=_maxSpeed;
		}
	}

	void Flap(){
		foreach(AudioSource a in _flapSources){
			if(!a.isPlaying){
				a.clip=_flap;
				a.Play();
				break;
			}
		}
	}

	void OnDrawGizmos(){
		Gizmos.color=Color.blue;
		Gizmos.DrawRay(transform.position,_velocity);
		Gizmos.DrawSphere(transform.position+transform.right*_turnRadius,0.5f);
		Gizmos.color=Color.red;
		//Gizmos.DrawRay(transform.position,_flatRight);
	}
}
